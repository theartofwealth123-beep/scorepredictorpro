<script>
  /************* AUTH + TRIAL LAYER *************/
  const ADMIN_EMAIL = "ben_sovilla@yahoo.com";
  const TRIAL_DAYS = 3;
  let authMode = "login";

  function getUsers() {
    try { return JSON.parse(localStorage.getItem("sp_users") || "{}"); }
    catch { return {}; }
  }

  function saveUsers(users) {
    localStorage.setItem("sp_users", JSON.stringify(users));
  }

  function getCurrentUser() {
    try { return JSON.parse(localStorage.getItem("sp_currentUser") || "null"); }
    catch { return null; }
  }

  function setCurrentUser(user) {
    if (user) localStorage.setItem("sp_currentUser", JSON.stringify(user));
    else localStorage.removeItem("sp_currentUser");
    renderAuthUI();
    checkAccessAndRender();
  }

  function isTrialActive(user) {
    if (!user || !user.trialStart) return false;
    const start = new Date(user.trialStart).getTime();
    const now = Date.now();
    const diffDays = (now - start) / (1000 * 60 * 60 * 24);
    return diffDays < TRIAL_DAYS;
  }

  function remainingTrialText(user) {
    if (!user || !user.trialStart) return "No trial started yet.";
    const start = new Date(user.trialStart).getTime();
    const now = Date.now();
    const diffMs = start + TRIAL_DAYS * 24 * 60 * 60 * 1000 - now;
    if (diffMs <= 0) return "Your free trial has expired.";
    const remainingDays = diffMs / (1000 * 60 * 60 * 24);
    const days = Math.floor(remainingDays);
    const hours = Math.floor((remainingDays - days) * 24);
    if (days <= 0) return `Trial active: about ${hours}h left`;
    return `Trial active: about ${days}d ${hours}h left`;
  }

  function userHasAccess(user) {
    if (!user) return false;
    if (user.isAdmin) return true;
    if (user.isSubscribed) return true;
    if (isTrialActive(user)) return true;
    return false;
  }

  function renderAuthUI() {
    const user = getCurrentUser();
    const authControls = document.getElementById("authControls");
    const paywallTrialText = document.getElementById("trialStatusText");
    if (!authControls) return;

    if (!user) {
      authControls.innerHTML = `
        <button class="btn btn-outline" onclick="openAuthModal('login')">Log in</button>
        <button class="btn btn-primary" onclick="openAuthModal('signup')">Start Free Trial</button>
      `;
      if (paywallTrialText) {
        paywallTrialText.textContent = "Not signed in. Create an account to start your free 3-day trial.";
      }
    } else {
      const accessText = userHasAccess(user)
        ? (isTrialActive(user) && !user.isSubscribed && !user.isAdmin
            ? remainingTrialText(user)
            : (user.isSubscribed ? "Subscription active." : "Admin access."))
        : "No active trial or subscription.";

      const roleBadge = user.isAdmin
        ? '<span class="badge">Admin</span>'
        : user.isSubscribed
        ? '<span class="badge">Subscriber</span>'
        : isTrialActive(user)
        ? '<span class="badge">Trial</span>'
        : "";

      authControls.innerHTML = `
        <div class="user-label">
          Signed in as ${user.email}${roleBadge}
        </div>
        ${!user.isSubscribed && !user.isAdmin ? `
          <button class="btn btn-primary" onclick="fakeSubscribe()">Subscribe now</button>
        ` : ""}
        <button class="btn btn-danger" onclick="logout()">Log out</button>
      `;

      if (paywallTrialText) {
        paywallTrialText.textContent = accessText;
      }
    }
  }

  function checkAccessAndRender() {
    const user = getCurrentUser();
    const appContent = document.getElementById("appContent");
    const paywall = document.getElementById("paywall");
    if (!appContent || !paywall) return;

    if (userHasAccess(user)) {
      appContent.style.display = "block";
      paywall.style.display = "none";
    } else {
      appContent.style.display = "none";
      paywall.style.display = "block";
    }
  }

  function openAuthModal(mode) {
    authMode = mode || "login";
    const backdrop = document.getElementById("authModalBackdrop");
    const title = document.getElementById("authModalTitle");
    const desc = document.getElementById("authModalDesc");
    const primaryBtn = document.getElementById("authPrimaryBtn");
    const toggleText = document.getElementById("authToggleText");
    const toggleLink = document.getElementById("authToggleLink");
    const error = document.getElementById("authError");

    document.getElementById("authEmail").value = "";
    document.getElementById("authPassword").value = "";
    error.textContent = "";

    if (authMode === "login") {
      title.textContent = "Sign in to your account";
      desc.textContent = "Access your subscription or continue your free trial.";
      primaryBtn.textContent = "Sign in";
      toggleText.textContent = "Don't have an account?";
      toggleLink.textContent = "Create one";
    } else {
      title.textContent = "Create your account";
      desc.textContent = "Start your 3-day free trial. No payment required to begin.";
      primaryBtn.textContent = "Create account";
      toggleText.textContent = "Already have an account?";
      toggleLink.textContent = "Sign in";
    }

    primaryBtn.onclick = handleAuthSubmit;
    backdrop.classList.add("show");
  }

  function closeAuthModal() {
    document.getElementById("authModalBackdrop").classList.remove("show");
  }

  function toggleAuthMode() {
    authMode = authMode === "login" ? "signup" : "login";
    openAuthModal(authMode);
  }

  function handleAuthSubmit() {
    const email = document.getElementById("authEmail").value.trim().toLowerCase();
    const password = document.getElementById("authPassword").value;
    const error = document.getElementById("authError");
    error.textContent = "";
    if (!email || !password) {
      error.textContent = "Please enter email and password.";
      return;
    }
    const users = getUsers();
    if (authMode === "signup") {
      if (users[email]) {
        error.textContent = "An account with this email already exists. Try signing in.";
        return;
      }
      const newUser = {
        email,
        password,
        isAdmin: email === ADMIN_EMAIL,
        isSubscribed: false,
        trialStart: new Date().toISOString()
      };
      users[email] = newUser;
      saveUsers(users);
      setCurrentUser(newUser);
      closeAuthModal();
    } else {
      const existing = users[email];
      if (!existing || existing.password !== password) {
        error.textContent = "Invalid email or password.";
        return;
      }
      existing.isAdmin = email === ADMIN_EMAIL;
      users[email] = existing;
      saveUsers(users);
      setCurrentUser(existing);
      closeAuthModal();
    }
  }

  function logout() {
    setCurrentUser(null);
  }

  function fakeSubscribe() {
    const user = getCurrentUser();
    if (!user) return openAuthModal("signup");
    const users = getUsers();
    user.isSubscribed = true;
    users[user.email] = user;
    saveUsers(users);
    setCurrentUser(user);
    alert("Subscription activated (demo). In production this would happen after payment.");
  }

  /************* LEAGUE SCORING CONFIG *************/
  const leagueConfig = {
    NFL:  { avgPointsPerTeam: 22,  totalPointsStd: 10, homeAdvDefault: 2.5 },
    NBA:  { avgPointsPerTeam: 114, totalPointsStd: 15, homeAdvDefault: 3.0 },
    MLB:  { avgPointsPerTeam: 4.5, totalPointsStd: 3,  homeAdvDefault: 0.3 },
    NCAAF:{ avgPointsPerTeam: 29,  totalPointsStd: 12, homeAdvDefault: 3.5 },
    NCAAB:{ avgPointsPerTeam: 71,  totalPointsStd: 12, homeAdvDefault: 3.8 }
  };

  function roundOne(x) { return Math.round(x * 10) / 10; }

  function predictFromRealStats(homeStats, awayStats, league) {
    const cfg = leagueConfig[league];
    if (!cfg) throw new Error("Unknown league: " + league);

    const home = homeStats, away = awayStats;

    const baseTotal = cfg.avgPointsPerTeam * 2;

    const avgPaceIndex = (home.pace_index + away.pace_index) / 2;
    const avgSosIndex  = (home.sos_index + away.sos_index) / 2;
    const envMultiplier = avgPaceIndex * avgSosIndex;

    const matchupHome = home.off_index / away.def_index;
    const matchupAway = away.off_index / home.def_index;
    const matchupAvg = (matchupHome + matchupAway) / 2;

    const rawTotal = baseTotal * envMultiplier * matchupAvg;

    const homeEdgePoints = (home.home_adv_points ?? cfg.homeAdvDefault) || 0;
    const homeWeightBase = matchupHome * home.form_index * (1 + homeEdgePoints / Math.max(rawTotal, 1));
    const awayWeightBase = matchupAway * away.form_index;
    const weightSum = homeWeightBase + awayWeightBase || 1;
    const homeShare = homeWeightBase / weightSum;
    const awayShare = awayWeightBase / weightSum;

    const homeScoreRaw = rawTotal * homeShare;
    const awayScoreRaw = rawTotal * awayShare;
    const homeScore = roundOne(homeScoreRaw);
    const awayScore = roundOne(awayScoreRaw);
    const spread = Math.abs(homeScoreRaw - awayScoreRaw);

    let confidence;
    if (spread >= cfg.totalPointsStd * 0.6) confidence = "High";
    else if (spread >= cfg.totalPointsStd * 0.3) confidence = "Medium";
    else confidence = "Low";

    return {
      homeScore,
      awayScore,
      confidence,
      winner: homeScoreRaw >= awayScoreRaw ? home.team : away.team,
      spread: roundOne(spread),
      debug: {
        baseTotal,
        envMultiplier,
        matchupHome,
        matchupAway,
        homeShare,
        awayShare,
        avgPaceIndex,
        avgSosIndex,
        homeEdgePoints
      }
    };
  }

  /************* TEAM LISTS (from /data/all-teams.json) *************/
  let ALL_TEAMS = {};
  let teamsLoaded = false;

  async function loadAllTeams() {
    const leagueSel = document.getElementById('league');
    const homeSel = document.getElementById('homeTeam');
    const awaySel = document.getElementById('awayTeam');
    if (!leagueSel || !homeSel || !awaySel) return;

    homeSel.innerHTML = '<option value="">Loading teams…</option>';
    awaySel.innerHTML = '<option value="">Loading teams…</option>';
    homeSel.disabled = true;
    awaySel.disabled = true;

    try {
      const res = await fetch('/data/all-teams.json');
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      ALL_TEAMS = data || {};
      teamsLoaded = true;

      if (!ALL_TEAMS[leagueSel.value]) {
        const leagues = Object.keys(ALL_TEAMS);
        if (leagues.length) leagueSel.value = leagues[0];
      }

      populateTeamDropdowns();
    } catch (err) {
      console.error(err);
      homeSel.innerHTML = '<option value="">Error loading teams</option>';
      awaySel.innerHTML = '<option value="">Error loading teams</option>';
      alert("Error loading team list: " + err.message);
    }
  }

  function populateTeamDropdowns() {
    const leagueSel = document.getElementById('league');
    const homeSel = document.getElementById('homeTeam');
    const awaySel = document.getElementById('awayTeam');
    if (!leagueSel || !homeSel || !awaySel) return;

    const league = leagueSel.value;
    const teams = ALL_TEAMS[league] || [];

    homeSel.innerHTML = '<option value="">Select Home Team</option>';
    awaySel.innerHTML = '<option value="">Select Away Team</option>';

    teams.forEach(name => {
      const optH = document.createElement('option');
      optH.value = name;
      optH.textContent = name;
      homeSel.appendChild(optH);

      const optA = document.createElement('option');
      optA.value = name;
      optA.textContent = name;
      awaySel.appendChild(optA);
    });

    homeSel.disabled = false;
    awaySel.disabled = false;
  }

  /************* FETCH TEAM STATS FROM NETLIFY FUNCTION *************/
  async function fetchTeamStats(league, teamName) {
    const url = `/.netlify/functions/team-stats?league=${encodeURIComponent(league)}&team=${encodeURIComponent(teamName)}`;
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(`Stats API error for ${teamName}: ${res.status} ${res.statusText}`);
    }
    const data = await res.json();
    if (data.error) throw new Error(data.error);

    const required = ["off_index", "def_index", "pace_index", "sos_index", "form_index", "ppg", "opp_ppg"];
    for (const key of required) {
      if (typeof data[key] !== "number") {
        throw new Error(`Missing or invalid "${key}" in stats response for ${teamName}`);
      }
    }

    return {
      league: data.league || league,
      team: data.team || teamName,
      off_index: data.off_index,
      def_index: data.def_index,
      pace_index: data.pace_index,
      sos_index: data.sos_index,
      form_index: data.form_index,
      ppg: data.ppg,
      opp_ppg: data.opp_ppg,
      home_adv_points: typeof data.home_adv_points === "number" ? data.home_adv_points : 0
    };
  }

  /************* PREDICT BUTTON HANDLER *************/
  async function predictScore() {
    const league = document.getElementById('league').value;
    const homeTeam = document.getElementById('homeTeam').value.trim();
    const awayTeam = document.getElementById('awayTeam').value.trim();

    if (!homeTeam || !awayTeam) {
      alert('Select both teams from the dropdowns.');
      return;
    }
    if (homeTeam.toLowerCase() === awayTeam.toLowerCase()) {
      alert('Teams must be different.');
      return;
    }

    try {
      document.getElementById('confidence').textContent = 'Loading stats from backend...';

      const [homeStats, awayStats] = await Promise.all([
        fetchTeamStats(league, homeTeam),
        fetchTeamStats(league, awayTeam)
      ]);

      const result = predictFromRealStats(homeStats, awayStats, league);

      document.getElementById('confidence').textContent = result.confidence + ' confidence';
      document.getElementById('homeTeamName').textContent = homeStats.team;
      document.getElementById('awayTeamName').textContent = awayStats.team;
      document.getElementById('homeScore').textContent = result.homeScore;
      document.getElementById('awayScore').textContent = result.awayScore;
      document.getElementById('winner').textContent = result.winner;
      document.getElementById('spread').textContent = 'Spread: ' + result.spread.toFixed(1);

      document.getElementById('homeStatsTitle').textContent = homeStats.team + ' Profile';
      document.getElementById('homeStats').innerHTML = `
        <div class="stat-row"><span>Off Index</span><span>${homeStats.off_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Def Index</span><span>${homeStats.def_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Pace Index</span><span>${homeStats.pace_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>SOS Index</span><span>${homeStats.sos_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Form Index</span><span>${homeStats.form_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>PPG</span><span>${homeStats.ppg.toFixed(1)}</span></div>
        <div class="stat-row"><span>Opp PPG</span><span>${homeStats.opp_ppg.toFixed(1)}</span></div>
      `;

      document.getElementById('awayStatsTitle').textContent = awayStats.team + ' Profile';
      document.getElementById('awayStats').innerHTML = `
        <div class="stat-row"><span>Off Index</span><span>${awayStats.off_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Def Index</span><span>${awayStats.def_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Pace Index</span><span>${awayStats.pace_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>SOS Index</span><span>${awayStats.sos_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>Form Index</span><span>${awayStats.form_index.toFixed(3)}</span></div>
        <div class="stat-row"><span>PPG</span><span>${awayStats.ppg.toFixed(1)}</span></div>
        <div class="stat-row"><span>Opp PPG</span><span>${awayStats.opp_ppg.toFixed(1)}</span></div>
      `;

      const d = result.debug;
      const reasoning = `
        Base ${league} total is ${d.baseTotal.toFixed(1)} points. After adjusting for pace
        (${d.avgPaceIndex.toFixed(2)}x) and strength of schedule (${d.avgSosIndex.toFixed(2)}x), the environment
        multiplier is ${d.envMultiplier.toFixed(2)}. Offense vs defense matchups give ${homeStats.team} a factor of
        ${d.matchupHome.toFixed(2)} and ${awayStats.team} ${d.matchupAway.toFixed(2)}. Combined with recent form and a home
        edge of ${d.homeEdgePoints.toFixed(1)} points, the model assigns ${homeStats.team} about ${(d.homeShare * 100).toFixed(1)}%
        of the scoring share and projects a spread of ${result.spread.toFixed(1)}.
      `;
      document.getElementById('reasoningText').textContent = reasoning.replace(/\s+/g, " ").trim();
      document.getElementById('results').classList.add('show');
      document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
    } catch (err) {
      console.error(err);
      alert('Could not load stats. Check league/team or try again.');
    }
  }

  /************* INIT *************/
  document.addEventListener("DOMContentLoaded", () => {
    renderAuthUI();
    checkAccessAndRender();
    loadAllTeams();

    const leagueSel = document.getElementById('league');
    if (leagueSel) {
      leagueSel.addEventListener('change', () => {
        if (teamsLoaded) populateTeamDropdowns();
      });
    }
  });
</script>
